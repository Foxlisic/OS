; --------------------------------
; В модуле размещены функции для управления памятью
;
; Память в ОС moonlix-64 является проксируемой и выделяется на всем объеме,
; который доступен и даже не доступен (происходит подкачка с диска)
; 
; Проксирование происходит по принципу
;
; mov r8, <block_id>         ; номер блока
; mov r8, [0x900000 + r8*8] ; узнать где лежит блок

; mov rax, [r8 + <нужное смещение>]
; ---

; Зарегистрировать новую область памяти определенного размера
; --------------------------------------------------------------------------------
; вход:  rax - размер новой области памяти
; выход: rax - ID блока памяти (если 0 - то ошибка, код ошибки в rbx)
;        rdi - линейный адрес выделенного блока
;        Коды ошибок: 1 (требуется сбор мусора), 2 (нет свободных ячеек)

memalloc:

    ; Адрес начала "кучи"
    mov rsi, HEAP_ADDR

    ; rax = (rax < 8) ? 8 : rax;
    mov   rbx, 8
    cmp   rax, rbx
    cmovc rax, rbx

.loop:

    ; rbx = Количество байт в блоке + бит занятости блока (64-й бит)
    mov rbx, [rsi]

    ; Если rbx=0 - это значит, что мы прошли все ранее выделенные блоки и ничего
    ; не нашли, чтобы выделить их снова - переходим к особой процедуре выделения
    and rbx, rbx   
    je  .block_free_add

    ; Если бит установлен, то значит, этот блок занят, переходим к другому блоку
    bt  rbx, 63
    jc .block_next

    ; Иначе блок не занят, проверяем его размер с тем, что нам необходим
    mov rcx, rbx

    ; rbx = rcx - 24 -- больше этого размера выделять нельзя в этом блоке
    ; Размер запрашиваемого блока меньше, 
    ; чем размер блока, который требуется
    sub rbx, 24
    cmp rax, rbx
    jle .block_split_add 

    ; Перейти к следующему блоку (если не вмещается запрашиваемый в свободный)
    add rsi, rcx
    jmp .loop

; К следующему блоку и повтор поиска
.block_next:
    
    btr rbx, 63
    add rsi, rbx     
    jmp .loop

; Разделить блок на 2 части - занятый и не занятый
.block_split_add:

    push rsi
    mov  rdi, [rsi]       ; Размер свободного блока, который делим

    add  rax, 8
    mov  [rsi], rax       ; Записать кол-во байт на блок (который был свободен), но теперь занят
    bts  qword [rsi], 63  ; Установить флаг занятости 

    add  rsi, rax         ; Переход к следующему блоку
    sub  rdi, rax
    
    mov [rsi], rdi        ; Запись количества занятых байт для оставшегося свободным блока
    pop rdi

    ; Теперь запишем этот указатель в таблицу
    jmp .write_rdi


; Добавить свободный блок (тот, который в конце в "куче")
; --------------------------------------------------------
.block_free_add:

    ; Проверить на кол-во свободной памяти
    mov rdi, rsi
    add rax, 8   ; 8 байт = информация о доступности / количестве байт в блоке
    add rsi, rax ; Выделяемая область
    cmp rsi, [VIRTUAL_MEMORY]
    jb .ok_set_size

    ; Памяти для выделения не хватило - требуется дефрагментация памяти
    xor rax, rax
    mov rbx, 1
    ret

; Если проверка допустимого размера прошла успешно
; и не трубуется дифрагментация
.ok_set_size:    

    bts rax, 63    ; Установить бит "Занято"
    mov [rdi], rax ; Записать информацию о размере и занятости
    add rdi, 8     ; Получение указателя на выделенный блок памяти

; Обнаружение свободных ячеек в таблице указателей и запись
; -----------------------------------
.write_rdi:

    xor rax, rax
    inc rax

.table_loop:

    ; Проверка на 0. Если записан 0, то отдаем номер блока
    mov rbx, [HEAP_INDEX + 8*rax]
    and rbx, rbx
    je .ok_set

    inc rax
    cmp rax, 131072
    jne .table_loop ; 128k указателей

    ; Не хватает ячеек в таблице 
    xor rax, rax
    mov rbx, 2
    ret

; Найдена свободная ячейка памяти (RAX), записать туда RDI    
.ok_set:

    mov [HEAP_INDEX + 8*rax], rdi
    ret

; Освободить память
; --------------------------------------------------------------------------------
; вход: rax - ID блока памяти

memfree:

    ; Очистить область памяти как обычно
    mov  rcx, [HEAP_INDEX + 8*rax] ; Указатель
    sub  rcx, 8
    btr  qword [rcx], 63 ; Установить блок как свободный

    xor  rbx, rbx
    mov  [HEAP_INDEX + 8*rax], rbx ; Очистить ID в таблице указателей

    ; "Склеить" последовательно идущие друг за другой блоки
    ; ----
    xor rax, rax

.glue_loop:

    mov rbx, [rcx + rax]

    and rbx, rbx
    je .glue     ; Достигнут конец памяти
    bt rbx, 63
    jb .glue     ; Или первый занятый блок

    add rax, rbx
    jmp .glue_loop

.glue:    

    ; Записываем МАКСИМАЛЬНЫЙ размер "склеенных" блоко
    mov [rcx], rax
    ret

; Изменить размер памяти (возможно перенести)
; --------------------------------------------------------------------------------
memsize:

    ret

; Процесс дефрагментации всей памяти (отнимает немалое время)
; Его надо запускать в случае крайней необходимости
; --------------------------------------------------------------------------------
.defrag:

    ret    