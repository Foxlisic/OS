; ЗАГРУЗОЧНЫЙ СЕКТОР
; "Аз есм я, сектор"
; ----------------------------

; Самая главная часть в разработке ОС - это запуск загрузочного сектора. Без него вообще
; даже не стоит делать ОС. Сектор 0 - главный сектор. И если его не сделать, будет худо всем.

; Как скомпилировать
; ----------------------------------
;    1) fasm boot.asm
;    2) dd conv=notrunc if=boot.bin of=../c.img bs=446 count=1
;
; bs - количество записываемых байт ТОЛЬКО 446, т.к. 64 байта в конце занимают 4 раздела
; диска + 2 байта занимает слово 55AA (сигнатура)
; conv=notrunc -- не пересоздавать файл c.img заново

; Про MBR
; https://ru.wikipedia.org/wiki/Главная_загрузочная_запись

; Карта памяти загрузочного сектора
; ----------------------------------
; 7A00 - 7CFF Стек
; 7B00        [byte] Код диска от 80h. Это от BIOS, приходит в регистре dl
; 7C00 - 7FFF КОД нулевого сектора
; 8000        [dword] Адрес начала FAT32
; 8004        [dword] Начало данных 
; 8008        [dword] Секторов на кластер
; 8200        Временный кластер
; A000        Временный кластер
; C000 ...    Программа, может занимать и все оставшиеся 608кб памяти
; ----------------------------------

        include "macros.asm"

        org 0x7C00

        ; Зачем делать cli / cld - не знаю, но делаю для острастки
        cli
        cld

        ; А вот нули проставить надо везде.
        ; Иначе если этого не сделать, то может 
        ; что-то сломаться и не запуститься совсем

        xor ax, ax
        mov ds, ax
        mov es, ax
        mov ss, ax

        ; Тут я SP опустил так специально, чтобы не пересекался файл
        mov sp, 0x7B00 

        ; Сохранить номер запускного диска из BIOS
        ; Когда BIOS запускает бут-сектор, он передает ему параметр dl, где хранится
        ; номер диска (80h-FFh), или флоппи-диска, но это уже совсем рухлядь какая-то
        mov [0x7B00], dl 

        ; В этом куске кода проверяется наличие в BIOS возможности грузить данные,
        ; используя технологию DAP 
        mov ah, 0x41
        mov bx, 0x55AA    
        int 0x13
        jnc search

        ; Ошибка: не поддерживается DAP. Перезагрузка процессора.
        jmp boot_error       

        ; ------------------------
        ; Поиск раздела FAT32 (SI)
        ; ------------------------

search: mov cx, 4
        mov si, 0x7DBE
@@:     cmp [si + 4], byte 0x0B ; Это FAT32 ?
        je  fat32
        add si, 0x10            ; Следующий раздел
        loop @b

        ; Ошибка: не найден FAT32. Перезагрузка процессора.
        jmp boot_error;

        ; ------------------------
        ; Расчет параметров файловой системы
        ; ------------------------

fat32:  mov esi, [si + 8]    ; загружаем 1-й сектор раздела
        mov [DAP + 8], esi   ; пишем указатель
        call ldap            ; грузим 1-сектор

        ; +512 байт вперед
        add [DAP + 6], byte 32    ; следующие данные начать загружать уже в 0x8200 

        ; Старт FAT
        movzx ebx, word [0x800E]  ; Кол-во зарезервированных секторов
        mov [0x8000], esi
        add [0x8000], ebx         ; Записать адрес начала раздела [start_FAT]

        ; Расчет начала данных
        mov   eax, [0x8024]       ; eax = fat_count
        movzx ebx, byte [0x8010]  ; ebx = sectors_by_fat
        mul   ebx
        add   eax, [0x8000]
        mov   [0x8004], eax       ; 0x8004 = fat_count * sectors_by_fat + start_FAT

        movzx eax, byte [0x800D]  ; Количество секторов на кластер
        mov   [DAP + 2], al       ; Читать теперь не секторами, а кластерами
        mov   [0x8008], eax       ; 0x8008 = sectors_per_cluster (Секторов на кластер)

        ; ------------------------
        ; Поиск имени файла в корне
        ; ------------------------

lookup: mov eax, [0x802C]         ; Номер текущего кластера
        call loadcl               ; Загружаем кластер в память

        ; Начинаем поиск данных
        xor esi, esi
        mov ecx, [0x8008]         ; Секторов на кластер
        shl ecx, 4                ; = ^(9-5) (кол-во элементов в кластере), ^9 = 512, ^5=32 запись
                                  ; = cluster_size * 512 / 32 = cluster_size * 16 (shl ecx, 4)
        
        ; Поиск основного загрузочного файла
lpc:    push cx 
        push si
        mov  cx, 11
        mov  di, name 
        add  si, 0x8200
        rep  cmpsb
        pop  si
        jcxz found

        ; Последовательный перебор файлов
        pop cx
        add esi, 32  
        loop lpc

        ; Если не найдено ничего --> получить следующий кластер через таблицу FAT
        mov eax, [0x802C]
        call nextcl
        mov [0x802C], eax

        cmp eax, 0x0FFFFFF0
        jb  lookup ; есть еще кластеры

        ; Если все кластеры завершены, это ошибка - нужный файл не найден
        jmp boot_error

; Файл был успешно найден
; ------------------------------------------------------------------------------------------
; Начать скачивание файла в памяти по адресу 0xC000 (48 кб) 592 кб максимальный размер файла        

found:  pop cx ; т.к. есть push cx в ldc:

        ; Загрузка номера кластера в EAX
        mov ax, [0x8200 + esi + 0x14]
        shl eax, 16
        mov ax, [0x8200 + esi + 0x1A]
        mov di, 0x0C00

lprg:   mov [DAP + 6], di ; сегмент
        mov [0x802C], eax ; выборка кластера
        call loadcl       ; загрузка в память 
        call nextcl       ; поиск следующего кластера

        ; К следующему сегменту
        mov ebx, [0x8008]
        shl bx, 5
        add di, bx

        ; есть еще кластеры?
        cmp eax, 0x0FFFFFF0
        jb  lprg 

        ; ------------------------
        ; При загрузке кластера могут быть "лишние" данные
        ; ЗАПУСК!
        ; ------------------------

        jmp far 0:0xC000

        ; ------------------------
        ; Ошибка загрузки   
        ; ------------------------
 
boot_error:
        
        jmp 0f000h:0fff0h;        
        
        ; ------------------------
        ; Загрузить сектор с сохранением контекста
        ; ------------------------

ldap:   pusha
        mov ah, 0x42
        mov si, DAP
        mov dl, [0x7B00]
        int 0x13
        popa
        ret

        ; ------------------------
        ; Загрузка кластера. eax - номер кластера
        ; ------------------------

loadcl: pusha
        sub  eax, 2 ; cluster - 2
        mul  dword [0x8008] ; количество секторов на кластер
        add  eax,  [0x8004] ; (cluster-2)*sectors_by_cluster + data_cluster
        mov  [DAP + 8], eax
        call ldap ; прочитать кластер
        popa
        ret

        ; ------------------------
        ; Определить следующий кластер по текущему EAX     
        ; ------------------------

nextcl: shl eax, 2
        xor edx, edx
        mov ebx, 512
        div ebx           ; eax - номер сектора, edx - смещение в секторе
        add eax, [0x8000] ; FAT_sector + (eax*4 / 512) -- скачать нужный сектор FAT

        ; Скачать tmp-данные 
        mov [DAP + 6], word 0x0A00 ; 0xA000 .. 0xBxxx
        mov [DAP + 8], eax 
        call ldap
        mov [DAP + 6], word 0x0820 ; Вернуть указатель на 0x8200 

        ; Вычисляем следующий кластер
        mov eax, [0xA000 + edx]
        ret

        ; -----------------------------------
        ; Данные для загрузки сектора в DAP
        ; -----------------------------------

DAP:    dw 0x0010  ; 0 размер DAP = 16
        dw 0x0001  ; 2 читать 1 сектор (вначале)
        dw 0x0000  ; 4 смещение (0)
        dw 0x0800  ; 6 сегмент (800h * 10h = 8000:0000)
        dq 0       ; 8 номер сектора от 0 до N-1

        ; Имя искомого файла
name:   db 'OPENOS  BIN';

        ; Остаток места заполнить нулями
        times 7c00h + (512 - 2 - 64) - $ db 0 

        ; -------------------------------------------------------------------------
        ; ЭТО СИСТЕМНАЯ ОБЛАСТЬ. НЕ ПЕРЕТИРАТЬ!
        ; 
        ; 0x1BE ... 0x1FD Таблица разделов (4 раздела)
        ; 0x1FE           сигнатура 55AA
        ; -------------------------------------------------------------------------

        times 64 db 0xff ; Таблица разделов будет заполнена оригинальной таблицей
        dw 0xAA55        ; Сигнатура boot sector