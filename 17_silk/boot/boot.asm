; ЗАГРУЗОЧНЫЙ СЕКТОР
; "Аз есм я, сектор"
; ----------------------------------------------------------------------
; Про MBR
; https://ru.wikipedia.org/wiki/Главная_загрузочная_запись
;
; Самая главная часть в разработке ОС - это запуск загрузочного сектора. 
; Без него вообще даже не стоит делать ОС. Сектор 0 - главный сектор. И 
; если его не сделать, будет худо всем.
;
; Как скомпилировать
; ----------------------------------------------------------------------
;
; fasm boot.asm && dd conv=notrunc if=boot.bin of=../disk.img bs=446 count=1
;
; bs - количество записываемых байт ТОЛЬКО 446, т.к. 64 байта в конце 
; занимают 4 раздела диска + 2 байта занимает слово 55AA (сигнатура)
; conv=notrunc -- не пересоздавать файл c.img заново
;
; HiMem (начало в $100000)
; ----------------------------------------------------------------------
; 0x0000 - 0x01FF Копия boot-sector
; 0x0200 - 0x03FF Стек
; 0x0400 - 0x05FF Сектор с данными о FAT32
; 0x0600 - 0x7FFF Кластер (макс. объем 30кб)
; 0x8000 - 0x81FF Сектор FAT-ссылок на другие кластеры
; ----------------------------------------------------------------------
; Программа загружается по адресу $00000800 - $0009FFFF (638b)
; Связано с тем, что по адресам   $00000000 - $000007FF будет IDT
; ----------------------------------------------------------------------

        macro brk { xchg bx, bx }

        org 0x0010       

        ; Зачем делать cli / cld - не знаю, но делаю для острастки
        cli
        cld

        ; Скопировать код в HIMEM
        xor     ax, ax
        mov     ds, ax
        mov     ax, 0xffff
        mov     es, ax
        mov     ss, ax
        mov     cx, 256
        mov     si, 0x7c00
        mov     di, 0x0010

        ; Загружено будет в 0x100000
        rep     movsw        
        mov     ds, ax

        ; Сохранить номер запускного диска из BIOS
        ; Когда BIOS запускает бут-сектор, он передает ему параметр dl, где хранится
        ; номер диска (80h-FFh), или флоппи-диска, но это уже совсем рухлядь какая-то

        mov     [0x01FF + 0x10], dl 

        ; Хитрый переход в HiMem
        jmp     0xFFFF : boot_jump

boot_jump:

        ; Указатель стека находится в HiMem (а самом верху)
        mov     sp, 0xFFF0 

        ; В этом куске кода проверяется наличие в BIOS возможности грузить данные,
        ; используя технологию DAP 

        mov     ah, 0x41
        mov     bx, 0x55AA
        int     0x13
        jnb     search
        jmp     boot_error              ; Ошибка: не поддерживается DAP

; ----------------------------------------------------------------------
; Поиск раздела FAT32 (SI) в таблице разделов MBR 

search: 

        mov     cx, 4
        mov     si, 0x01BE + 0x10
@@:     cmp     [si + 4], byte 0x0B     ; Это FAT32 ?
        je      fat32
        add     si, 0x10                ; Следующий раздел
        loop    @b
        jmp     boot_error              ; Ошибка: не найден FAT32

; ----------------------------------------------------------------------
; Расчет параметров файловой системы

fat32:
        mov     esi, [si + 8]            ; загружаем номер сектора, где находится 1-й сектор раздела
        mov     [DAP + 8], esi           ; пишем указатель на сектор
        call    ldap                     ; грузим 1-сектор

        ; +512 байт вперед
        add     [DAP + 4], word 512      ; Данные кластера загружать уже в $100600 

        ; Старт FAT
        movzx   ebx, word [0x041E]       ; Кол-во зарезервированных секторов
        mov     [0x0410], esi
        add     [0x0410], ebx            ; Записать адрес начала раздела [start_FAT]

        ; Расчет начала данных
        mov     eax, [0x0434]            ; eax = fat_count
        movzx   ebx, byte [0x0420]       ; ebx = sectors_by_fat
        mul     ebx
        add     eax, [0x0410]            ; eax = start_FAT
        mov     [0x0414], eax            ; 0x0004 = fat_count * sectors_by_fat + start_FAT
        movzx   eax, byte [0x041D]       ; Количество секторов на кластер
        mov     [DAP + 2], al            ; Читать теперь не секторами, а кластерами
        mov     [0x0418], eax            ; 0x0008 = sectors_per_cluster (Секторов на кластер)

; ----------------------------------------------------------------------
; Поиск имени файла в корне

lookup: mov     eax, [0x043C]   ; Номер текущего кластера
        call    loadcl          ; Загружаем кластер в память [$0600...]
        xor     esi, esi        ; Начинаем поиск данных
        mov     ecx, [0x0418]   ; Секторов на кластер
        shl     ecx, 4          ; = ^(9-5) (кол-во элементов в кластере), ^9 = 512, ^5=32 запись
                                ; = cluster_size * 512 / 32 = cluster_size * 16 (shl ecx, 4)        
lpc:    push    cx              ; Поиск основного загрузочного файла
        push    si
        mov     cx, 11
        mov     di, name 
        add     si, 0x0610
        rep     cmpsb
        pop     si
        jcxz    found

        ; Последовательный перебор файлов
        pop     cx
        add     esi, 32  
        loop    lpc

        ; Если не найдено ничего --> получить следующий кластер через таблицу FAT
        mov     eax, [0x043C]
        call    nextcl
        mov     [0x043C], eax
        cmp     eax, 0x0FFFFFF0
        jb      lookup ; есть еще кластеры?

        ; Если все кластеры завершены, это ошибка - нужный файл не найден
        jmp     boot_error

; ----------------------------------------------------------------------
; Файл был успешно найден! Скачивание его в память по кластерам.
; 638,5 кб максимальный размер файла

found:
        pop     cx                             ; Есть push cx в ldc:
        mov     ax, word [0x0610 + esi + 0x14] ; Загрузка номера найденного кластера в EAX
        shl     eax, 16
        mov     ax,  [0x0610 + esi + 0x1A]
        mov     di,  0x0080         ; Писать кластер, начиная с 0x0800
lprg:   mov     [DAP + 6], di       ; Куда писать в память
        mov     [DAP + 4], word 0   ; Смещение (0)
        call    loadcl              ; Загрузка кластера в память
        call    nextcl              ; Поиск следующего кластера
        mov     ebx, [0x0418]       ; Кол-во секторов на кластер
        shl     bx, 5
        add     di, bx              ; Перейти к следующему сегменту
        cmp     eax, 0x0FFFFFF0     ; Есть еще кластеры?
        jb      lprg 

; ----------------------------------------------------------------------
; ЗАПУСК
; ------
; Warning: при загрузке последнего кластера могут быть "лишние" данные. 

        jmp     far 0:0x0800

; ----------------------------------------------------------------------
; Ошибка загрузки AX 
 
boot_error:

        mov     cx, 8
.loop:  rol     eax, 4
        push    eax
        and     al, 0xF
        cmp     al, 10
        jb      @f
        add     al, 7
@@:     add     al, '0'
        mov     ah, 0xe
        int     0x10   
        pop     eax
        loop    .loop  
        jmp     $
        
; ----------------------------------------------------------------------
; Загрузить сектор с сохранением контекста

ldap:   pusha
        mov     ah, 0x42
        mov     si, DAP
        mov     dl, [0x01FF + 10h]
        int     0x13
        popa
        ret

; ----------------------------------------------------------------------
; Загрузка кластера. eax - номер кластера

loadcl: pusha
        sub     eax, 2          ; cluster - 2
        mul     dword [0x0418]  ; количество секторов на кластер
        add     eax,  [0x0414]  ; (cluster-2)*sectors_by_cluster + data_cluster
        mov     [DAP + 8], eax
        call    ldap            ; прочитать кластер
        popa
        ret

; ----------------------------------------------------------------------
; Определить следующий кластер по текущему EAX

nextcl: shl     eax, 2
        xor     edx, edx
        mov     ebx, 512
        div     ebx           ; eax - номер сектора, edx - смещение в секторе
        add     eax, [0x0410] ; FAT_sector + (eax*4 / 512) -- скачать нужный сектор FAT

        ; Скачать tmp-данные 
        mov     [DAP + 6], word 0xFFFF ; HiMem
        mov     [DAP + 4], word 0x8010 ; $108000 Временный кластер
        mov     [DAP + 8], eax 
        call    ldap
        mov     [DAP + 4], word 0x0610 ; $100600 Вернуть обратно

        ; Вычисляем следующий кластер
        mov     eax, [0x8010 + edx]
        ret

; ----------------------------------------------------------------------
; Данные для загрузки сектора в DAP

DAP:    dw 0x0010  ; 0 размер DAP = 16
        dw 0x0001  ; 2 читать 1 сектор (вначале)
        dw 0x0410  ; 4 смещение (0)
        dw 0xFFFF  ; 6 сегмент (FFFF0h + 410h = 100400h)
        dq 0       ; 8 номер сектора от 0 до N-1

        ; Имя искомого файла
name:   db 'SYS     BIN';

        ; Остаток места заполнить нулями
        times 10h + (512 - 2 - 64) - $ db 0xFF

; -------------------------------------------------------------------------
; ЭТО СИСТЕМНАЯ ОБЛАСТЬ. НЕ ПЕРЕТИРАТЬ!
; 
; 0x1BE ... 0x1FD Таблица разделов (4 раздела)
; 0x1FE           сигнатура 55AA
; -------------------------------------------------------------------------

        times 64 db 0xff ; Таблица разделов будет заполнена оригинальной таблицей
        dw 0xAA55        ; Сигнатура boot sector
