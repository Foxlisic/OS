
; ----------------------------------------------------------------------
; При загрузке BIOS, код бутсектора помещается в память
; по адресу [0000 : 7C00h]
; ----------------------------------------------------------------------

        B_SECTOR_BY_CLUSTER         equ 0x0D    ; секторов в кластере
        W_RESERVED_SECTORS          equ 0x0E    ; секторов до FAT
        B_FAT_COUNT                 equ 0x10    ; кол-во FAT
        W_ROOT_ELEMENTS             equ 0x11    ; кол-во элементов в корне
        W_SECTORS_AT_FAT            equ 0x16    ; секторов в FAT

        macro   brk { xchg bx, bx }
        org     7C00h

        sti             ; включить, все-таки, прерывания
                        ; для того, чтобы сработал ctrl+alt+del если что
        cld             ; флаг направления D=0, т.е. строковые функции
                        ; будут сканировать память вперед

        xor     ax, ax  ; ax = 0
        mov     ds, ax  ; очистим ds, es
        mov     es, ax
        mov     ss, ax
        mov     sp, 7B00h   ; стек должен быть внизу

        ; BIOS DAP https://en.wikipedia.org/wiki/INT_13H
        mov     ah, 41h             ; Проверка на существование возможности BIOS
        mov     bx, 55AAh           ; загружать файлы с помощью блока DAP
        mov     [7C00h - 2h], dl    ; надо записать DL
        int     13h                 ; в нем находится номер диска, который нам дал BIOS        

        ; Если DAP нет в системе, будет на экран выдана ошибка
        mov     si, dap_not_present
        jc      kprints

        ; Займемся поиском активных разделов, чтобы понять, откуда нам
        ; грузить файловую систему FAT16.
        ;
        ; Подробности тут https://en.wikipedia.org/wiki/Master_boot_record

        ; начинаем поиск разделов с адреса 1BEh (в бутсекторе)
        ; но так как у нас бутсектор загружен в 7C00h, то добавляем еще это
        mov     si, 1BEh + 7C00h

        ; Всего в MBR могут быть 4 раздела описаны, в каждом разделе по 16 байт
        ; по смещению +4 в байте находится код файловой системы, для FAT этот
        ; код равен 6

search_loop:

        cmp     [si + 4], byte 06h      ; проверим, что это FAT16 (06)
        je      fs_fat16_found          ; если да, переходим далее
        add     si, 16                  ; если нет, перейдем к рассмотрению следующего раздела
        cmp     si, 1FEh + 7C00h        ; если мы еще НЕ достигли 4-го раздела
        jne     search_loop             ; то проверим еще раз новый адрес
        mov     si, err_partition_not_found ; при достижении придела, выдается ошибка
        jmp     kprints

; Секция FAT16 была успешно найдена
; ----------------------------------------------------------------------

fs_fat16_found:


        ; по адресу +8 в таблице разделов хранится 32-х битный LBA
        ; первого сектора раздела, который нам нужен (это FAT16)

        mov     ebp, [si + 8]
        call    load_sector     ; загрузим первый сектор FAT16

        ; СТРУКТУРА:
        ; - резервированные сектора (включая 1-й сектор)
        ; - fat1
        ; - fat2
        ; - корневые элементы
        ; - данные

        ; парсим данные из первого сектора
        xor     eax, eax
        mov     ax, [7E00h + W_RESERVED_SECTORS]    ; получим кол-во секторов
        add     ebp, eax                            ; теперь ebp указывает на сектор с FAT
        mov     [fat_sector], ebp                   ; сохраним это значение

        ; рассчитаем кол-во fat * размер fat в секторах
        ; чтобы получить указатель на сектор с перечислением корневых
        ; элементов

        xor     bx, bx
        mov     ax, [7E00h + W_SECTORS_AT_FAT]
        mov     bl, [7E00h + B_FAT_COUNT]
        mul     bx

        ; добавим еще, и получится нужное смещение в файле
        add     ebp, eax
        mov     [entroot_sector], ebp

        ; 1 элемент занимает 32 байта
        ; N элементов * 32 = размер таблицы в байтах N shl 5
        ; Но нам нужно вычислить, сколько корневая таблица занимает
        ; в секторах, т.е. делим на 512
        ; N * 32 / 512 = N / 16

        mov     ax, [7E00h + W_ROOT_ELEMENTS]
        shr     ax, 4       ; это равнозначно делению на 16
        mov     [sectors_in_root], ax   ; количество секторов в корневой директории
        add     ebp, eax    ; здесь, в этом секторе, начинается область с данными (кластеры)
        mov     [data_sector], ebp

        ; Начнем поиск в корневом каталоге
        ; будем загружать последовательно, по одному сектору

        ; загрузим в DAP, который скачивает кластеры, то кол-во секторов
        ; которое нужно скачать за 1 раз
        
        mov     al, [7E00h + B_SECTOR_BY_CLUSTER]
        mov     [DAP_cluster + 2], al

        ; загрузим указатель на сектор с корневой директории
        mov     ebp, [entroot_sector]

load_next_root_sector:

        call    load_sector
        mov     si, 7E00h

search_name:   ; Начнем искать файл

        mov     di, start_file
        mov     cx, 11 + 1
        push    si              ; сохранить si
        repz    cmpsb           ; инструкция сравнения строк (количество символов cx = 12)
                                ; сравнивает, пока символы [si] и [di] равны (REPZ)
        pop     si
        jcxz    file_found      ; если CX=0, значит, строка совпадает

        add     si, 32          ; перейти к следующему элементу
        cmp     si, 8000h       ; конец сектора?
        jne     search_name     ; если нет, то проверить след. элемент

        inc     ebp                     ; скачать следующий сектор
        dec     word [sectors_in_root]  ; уменьшить кол-во секторов на 1
        jne     load_next_root_sector   ; и загрузить опять, начать поиск

        ; если все секторы просмотрены, выдать ошибку
        mov     si, file_not_found
        jmp     kprints

        ; файл найден, его позиция сейчас находится в SI

file_found:

        ; Определяем первый кластер
        xor     ebp, ebp       ; Старшей части не может быть
        mov     bp, [si + 1Ah] ; Младшая часть кластера

load_next_cluster:

        ; загрузка кластера в память
        push    ebp
        call    load_cluster

        ; кол-во секторов преобразуем в сегменты
        ; 1 сектор = 512 байт; 512 / 16 (размер сегмента) = 32
        mov     ax, [DAP_cluster + 2]
        shl     ax, 5                   ; умножение на 32
        add     [DAP_cluster + 6], ax   ; загружать теперь будет в памяти
                                        ; в следующий "кластер" (смещаем сегмент)

        ; теперь надо извлечь следующий номер кластера, чтобы знать
        ; какой загружать теперь
        pop     ebx

        ; 1 сектор = 2 байта в FAT
        ; т.е. 256 секторов = 1 сектор FAT
        mov     ebp, ebx
        shr     ebp, 8              ; делим на 256 номер кластера
        add     ebp, [fat_sector]   ; вычисляем начало
        and     bx, 0x00FF          ; рассчитываем смещение в секторе для поиска
        add     bx, bx              ; умножение на 2 (word)
        call    load_sector         ; загрузка сектора для извлечения данных
        mov     bp, [7E00h + bx]    ; следующий кластер
        cmp     bp, 0xFFF8
        jb      load_next_cluster   ; пока bp < 0xFFF8, загружать кластеры

        ; закончить загрузку и перйти к программе
        ; довольно объемный бут-сектор оказался

        jmp     0x0800 : 0

; ----------------------------------------------------------------------
; Функция загрузки сектора
; EBP - номер сектора для загрузки его в 0000 : 7E00h

load_sector:

        mov     si, DAP_sector          ; указатель на блок параметров загрузки сектора
        mov     [si + 8], ebp           ; копирует номер сектора в DAP

.runload:

        mov     ah, 42h                 ; команда чтения
        mov     dl, [7C00h - 2h]        ; тут у нас храниться номер диска
        int     13h                     ; выполняем чтение
        mov     si, err_fail_sector
        jc      kprints                 ; если ошибка загрузки, выдаем ошибку на экран
        ret

load_cluster:

        xor     eax, eax
        sub     ebp, 2                   ; обязательно нужно вычесть -2, так устроено в FAT
        mov     ax, [DAP_cluster + 2]    ; кол-во секторов на кластер
        mul     ebp                      ; умножаем на номер кластера
        xchg    eax, ebp                 ; результат помещаем в EBP из EAX

        add     ebp, [data_sector]       ; прибавляем стартовый адрес, где находятся данные
        mov     si, DAP_cluster          ; указатель на блок параметров загрузки кластера
        mov     [si + 8], ebp            ; копирует номер сектора в DAP
        jmp     load_sector.runload      ; переходим к загрузке

; ----------------------------------------------------------------------
; DS:SI - указатель строки

kprints:

        lodsb               ; грузим в AL из позиции DS:SI  символ
        and     al, al      ; если в AL=00
        je      $           ; то останавливаем программу
        mov     ah, 0Eh
        int     10h         ; печать символа на экране через BIOS
        jmp     kprints     ; к следующему символу

; ----------------------------------------------------------------------

DAP_sector:

        db      10h         ; +0 размер DAP (16 байт)
        db      00h         ; +1 не используется, должен быть 0
        dw      01h         ; +2 количество сектров для чтения (1)
        dw      7E00h       ; +4 смещение : сегмент (0 : 7E00h)
        dw      0000h       ; +6 куда будет загружаться сектор (прямо за бутсектором сделал)
        dq      0           ; +8 номер сектора, который нужно загрузить с диска (64 битный)
                            ;    первый сектор = 0

DAP_cluster:

        db      10h         ; +0 размер DAP (16 байт)
        db      00h         ; +1 не используется, должен быть 0
        dw      01h         ; +2 количество сектров для чтения кластера (зависит от FAT)
        dw      0000h       ; +4 смещение : сегмент (800h : 0000h)
        dw      0800h       ; +6 куда будет загружаться кластер
        dq      0           ; +8 номер сектора, который нужно загрузить с диска (64 битный)
                            ;    первый сектор = 0

; ----------------------------------------------------------------------

; Строка, которая выдается, если нет DAP в BIOS. Это маловероятно.
; эти надписи много места занимают
dap_not_present         db "DAP not present", 0
err_partition_not_found db "FAT16 not found", 0
err_fail_sector         db "Error loading sector", 0
file_not_found          db "Kernel not found!", 0
start_file              db "KERNEL  BIN" ; должен быть 11 символьный

; ----------------------------------------------------------------------
fat_sector      dd  ?       ; сектор с FAT
entroot_sector  dd  ?       ; сектор с корневым каталогом
data_sector     dd  ?       ; сектор с данными
sectors_in_root dw  ?       ; секторов в корневой директории
