set_descriptor:

    ; Создаёт дескриптор.
    ; DS:BX = дескриптор в GDT
    ; EAX = адрес сегмента
    ; EDX = предел сегмента
    ; CL = байт прав доступа (access_rights)

    push   eax
    push   ecx          ; Регистры EAX и ECX мы будем использовать.
    push   cx           ; Временно сохраняем значение access_rights.
    mov    cx, ax       ; Копируем младшую часть адреса в CX,
    shl    ecx, 16      ; и сдвигаем её в старшую часть ECX.
    mov    cx, dx       ; Копируем младшую часть предела в CX.
                        ; Теперь ECX содержит младшую часть дескриптора
    mov    [bx], ecx    ; Записываем младшую половину дескриптора в GDT.
    shr    eax, 16      ; EAX хранит адрес сегмента, младшую часть
                        ; которого мы уже использовали, теперь будем
                        ; работать со старшей, для чего сдвигаем её в
                        ; младшую часть EAX, т.е. в AX.
    mov    cl, ah       ; Биты адреса с 24 по 31
    shl    ecx, 24      ; сдвигаем в старший байт ECX, а биты адреса
    mov    cl, al       ; с 16 по 23 - в младший байт.
    pop    ax           ; Возвращаем из стека в AX значение access_rights
    mov    ch, al       ; и помещаем его во второй (из четырёх) байт ECX.
                        ; Всё, дескриптор готов. Старшую часть предела и биты GDXU
                        ; мы не устанавливаем и они будут иметь нулевые значения.
    mov    [bx+4], ecx  ; Дописываем в GDT вторую половину дескриптора
    add    bx,8         ; Переводим указатель в GDT на следующий дескриптор
    pop    ecx
    pop    eax
    ret
        
putzs:

    ; DS:BX = ZS                ; ZS = Zero-String - строка, оканчивающаяся нулевым (00h) байтом.
    ; ES:DI = позиция вывода    ; ES описывает сегмент видеопамяти, DI - смещение в нём.

    push    ax
    push    bx
    push    es
    push    di
    mov     ah, 1bh     ; В AH будет атрибут вывода - светло-циановые символы на синем фоне.

putzs_loop:

    mov    al, [bx]     ; Читаем байт из ZS-строки.
    inc    bx           ; Переводим указатель на следующий байт.
    cmp    al,0         ; Если байт равен 0,
    je     putzs_end    ; то переходим в конец процедуры.
    stosw               ; Иначе - записываем символ вместе с атрибутом в видеопамять
    jmp    putzs_loop   ; Повторяем процедуру для следующего байта из ZS-строки.

putzs_end:

    pop    di
    pop    es
    pop    bx
    pop    ax
    ret
